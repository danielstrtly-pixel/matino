-- Matino Database Schema
-- Run this in Supabase SQL Editor

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Chains (static data)
CREATE TABLE IF NOT EXISTS chains (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  logo TEXT,
  color TEXT,
  base_url TEXT,
  supported BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert supported chains
INSERT INTO chains (id, name, logo, color, base_url, supported) VALUES
  ('ica', 'ICA', 'ðŸ”´', '#e3000b', 'https://www.ica.se', true),
  ('hemkop', 'HemkÃ¶p', 'ðŸŸ ', '#ff6600', 'https://www.hemkop.se', true),
  ('coop', 'Coop', 'ðŸŸ¢', '#00aa46', 'https://www.coop.se', false),
  ('lidl', 'Lidl', 'ðŸ”µ', '#0050aa', 'https://www.lidl.se', false),
  ('willys', 'Willys', 'ðŸ”´', '#e4002b', 'https://www.willys.se', false)
ON CONFLICT (id) DO UPDATE SET
  name = EXCLUDED.name,
  supported = EXCLUDED.supported;

-- Stores
CREATE TABLE IF NOT EXISTS stores (
  id TEXT PRIMARY KEY, -- e.g., "hemkop-4147"
  chain_id TEXT NOT NULL REFERENCES chains(id),
  external_id TEXT NOT NULL, -- ID in the chain's system
  name TEXT NOT NULL,
  address TEXT,
  city TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(chain_id, external_id)
);

-- User's selected stores
CREATE TABLE IF NOT EXISTS user_stores (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  store_id TEXT NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, store_id)
);

-- Offers (cached from scraper)
CREATE TABLE IF NOT EXISTS offers (
  id TEXT PRIMARY KEY, -- Generated by scraper
  store_id TEXT NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  chain_id TEXT NOT NULL REFERENCES chains(id),
  name TEXT NOT NULL,
  brand TEXT,
  description TEXT,
  original_price DECIMAL(10,2),
  offer_price DECIMAL(10,2) NOT NULL, -- Per-unit price (for sorting)
  quantity INTEGER, -- For "X fÃ¶r Y" deals: how many items
  quantity_price DECIMAL(10,2), -- For "X fÃ¶r Y" deals: total price
  unit TEXT, -- "kg", "st", "l", etc.
  savings TEXT, -- "-25%", "2 fÃ¶r 50 kr", etc.
  image_url TEXT,
  valid_from DATE,
  valid_until DATE,
  category TEXT,
  max_per_household INTEGER,
  requires_membership BOOLEAN DEFAULT false,
  scraped_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for faster queries
CREATE INDEX IF NOT EXISTS idx_offers_store_id ON offers(store_id);
CREATE INDEX IF NOT EXISTS idx_offers_chain_id ON offers(chain_id);
CREATE INDEX IF NOT EXISTS idx_offers_scraped_at ON offers(scraped_at);
CREATE INDEX IF NOT EXISTS idx_user_stores_user_id ON user_stores(user_id);

-- Scrape jobs (track what's been scraped)
CREATE TABLE IF NOT EXISTS scrape_jobs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  store_id TEXT NOT NULL REFERENCES stores(id),
  status TEXT NOT NULL DEFAULT 'pending', -- pending, running, completed, failed
  offers_count INTEGER,
  duration_ms INTEGER,
  error TEXT,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- User preferences
CREATE TABLE IF NOT EXISTS user_preferences (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  household_size INTEGER DEFAULT 2,
  likes TEXT[] DEFAULT '{}', -- Array of liked ingredients/foods
  dislikes TEXT[] DEFAULT '{}', -- Array of disliked ingredients/foods
  allergies TEXT[] DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Row Level Security (RLS)
ALTER TABLE user_stores ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view their own stores"
  ON user_stores FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own stores"
  ON user_stores FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own stores"
  ON user_stores FOR DELETE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can view their own preferences"
  ON user_preferences FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own preferences"
  ON user_preferences FOR ALL
  USING (auth.uid() = user_id);

-- Public read access for chains, stores, offers
ALTER TABLE chains ENABLE ROW LEVEL SECURITY;
ALTER TABLE stores ENABLE ROW LEVEL SECURITY;
ALTER TABLE offers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can read chains"
  ON chains FOR SELECT
  USING (true);

CREATE POLICY "Anyone can read stores"
  ON stores FOR SELECT
  USING (true);

CREATE POLICY "Anyone can read offers"
  ON offers FOR SELECT
  USING (true);

-- Function to get offers for a user's selected stores
CREATE OR REPLACE FUNCTION get_user_offers(p_user_id UUID)
RETURNS TABLE (
  offer_id TEXT,
  store_id TEXT,
  store_name TEXT,
  chain_id TEXT,
  chain_name TEXT,
  chain_logo TEXT,
  name TEXT,
  brand TEXT,
  offer_price DECIMAL,
  original_price DECIMAL,
  unit TEXT,
  image_url TEXT,
  requires_membership BOOLEAN,
  scraped_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.id as offer_id,
    o.store_id,
    s.name as store_name,
    o.chain_id,
    c.name as chain_name,
    c.logo as chain_logo,
    o.name,
    o.brand,
    o.offer_price,
    o.original_price,
    o.unit,
    o.image_url,
    o.requires_membership,
    o.scraped_at
  FROM offers o
  JOIN stores s ON o.store_id = s.id
  JOIN chains c ON o.chain_id = c.id
  JOIN user_stores us ON us.store_id = o.store_id
  WHERE us.user_id = p_user_id
  ORDER BY o.scraped_at DESC, o.name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Insert some default stores
INSERT INTO stores (id, chain_id, external_id, name, city) VALUES
  ('hemkop-4147', 'hemkop', '4147', 'HemkÃ¶p Ã–stermalmstorg', 'Stockholm'),
  ('hemkop-2070', 'hemkop', '2070', 'HemkÃ¶p Fridhemsplan', 'Stockholm'),
  ('hemkop-2123', 'hemkop', '2123', 'HemkÃ¶p Odenplan', 'Stockholm')
ON CONFLICT (id) DO NOTHING;
